{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///Users/jackmu/Documents/haligram/nextjs/src/auth.ts"],"sourcesContent":["import NextAuth from \"next-auth\"\nimport GitHub from \"next-auth/providers/github\"\nimport { SignJWT } from \"jose\";\nimport { getSession } from \"next-auth/react\";\n\nexport const { handlers, auth, signIn, signOut } = NextAuth({\n\tproviders: [GitHub],\n})\n\nexport async function userWithToken() {\n\tconst user = await getSession();\n\tconst PRIVATE_KEY = await importPrivateKey(process.env.PARAGON_SIGNING_KEY!);\n\n\tif (user && user.user) {\n\t\ttry {\n\t\t\tconst paragonUserToken = await new SignJWT({\n\t\t\t\tsub: user.user.id,\n\t\t\t\taud: `useparagon.com/${process.env.NEXT_PUBLIC_PARAGON_PROJECT_ID}`,\n\t\t\t})\n\t\t\t\t.setProtectedHeader({ alg: \"RS256\" })\n\t\t\t\t.setIssuedAt()\n\t\t\t\t.setExpirationTime(\"24h\")\n\t\t\t\t.sign(PRIVATE_KEY);\n\n\t\t\treturn {\n\t\t\t\tuser,\n\t\t\t\tparagonUserToken,\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tconsole.error(\"Paragon signing error\", err);\n\t\t}\n\t}\n\treturn { user: null };\n}\n\nexport async function createParagonToken(userId: string) {\n\tconst PRIVATE_KEY = await importPrivateKey(process.env.PARAGON_SIGNING_KEY!);\n\ttry {\n\t\tconst paragonUserToken = await new SignJWT({ sub: userId, })\n\t\t\t.setProtectedHeader({ alg: \"RS256\" })\n\t\t\t.setIssuedAt()\n\t\t\t.setExpirationTime(\"24h\")\n\t\t\t.sign(PRIVATE_KEY);\n\n\t\treturn paragonUserToken;\n\t} catch (err) {\n\t\tconsole.error(\"Paragon signing error\", err);\n\t}\n}\n\n\n/*\n  Import a PEM encoded RSA private key, to use for RSA-PSS signing.\n  Takes a string containing the PEM encoded key, and returns a Promise\n  that will resolve to a CryptoKey representing the private key.\n  */\nexport async function importPrivateKey(pem: string) {\n\t// Replace encoded newlines with actual newlines\n\tpem = pem.replace(/\\\\n/g, \"\\n\");\n\n\t// Normalize newlines to '\\n'\n\tpem = pem.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n\n\t// Remove unnecessary whitespace and ensure proper PEM format\n\tpem = pem.trim();\n\n\tconst pemHeader = \"-----BEGIN PRIVATE KEY-----\";\n\tconst pemFooter = \"-----END PRIVATE KEY-----\";\n\n\tif (!pem.startsWith(pemHeader) || !pem.endsWith(pemFooter)) {\n\t\tthrow new Error(\"PEM format is incorrect.\");\n\t}\n\n\t// Fetch the part of the PEM string between header and footer\n\tconst pemContents = pem\n\t\t.substring(pemHeader.length, pem.length - pemFooter.length)\n\t\t.replace(/[\\s\\n]+/g, \"\"); // Remove all whitespace and newline characters\n\n\t// Base64 decode the string to get the binary data\n\tconst binaryDerString = Buffer.from(pemContents, \"base64\");\n\n\ttry {\n\t\treturn await globalThis.crypto.subtle.importKey(\n\t\t\t\"pkcs8\",\n\t\t\tbinaryDerString,\n\t\t\t{\n\t\t\t\tname: \"RSASSA-PKCS1-v1_5\",\n\t\t\t\thash: \"SHA-256\",\n\t\t\t},\n\t\t\ttrue,\n\t\t\t[\"sign\"]\n\t\t);\n\t} catch (err) {\n\t\tconsole.warn(\n\t\t\t\"Could not import signing key, it may be in an invalid format.\"\n\t\t);\n\t\tthrow err;\n\t}\n}\n"],"names":[],"mappings":";;;;;;;;;AAAA;AAAA;AACA;AAAA;AACA;AACA;;;;;AAEO,MAAM,EAAE,QAAQ,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,CAAA,GAAA,uJAAA,CAAA,UAAQ,AAAD,EAAE;IAC3D,WAAW;QAAC,uJAAA,CAAA,UAAM;KAAC;AACpB;AAEO,eAAe;IACrB,MAAM,OAAO,MAAM,CAAA,GAAA,uIAAA,CAAA,aAAU,AAAD;IAC5B,MAAM,cAAc,MAAM,iBAAiB,QAAQ,GAAG,CAAC,mBAAmB;IAE1E,IAAI,QAAQ,KAAK,IAAI,EAAE;QACtB,IAAI;YACH,MAAM,mBAAmB,MAAM,IAAI,uJAAA,CAAA,UAAO,CAAC;gBAC1C,KAAK,KAAK,IAAI,CAAC,EAAE;gBACjB,KAAK,CAAC,eAAe,EAAE,QAAQ,GAAG,CAAC,8BAA8B,EAAE;YACpE,GACE,kBAAkB,CAAC;gBAAE,KAAK;YAAQ,GAClC,WAAW,GACX,iBAAiB,CAAC,OAClB,IAAI,CAAC;YAEP,OAAO;gBACN;gBACA;YACD;QACD,EAAE,OAAO,KAAK;YACb,QAAQ,KAAK,CAAC,yBAAyB;QACxC;IACD;IACA,OAAO;QAAE,MAAM;IAAK;AACrB;AAEO,eAAe,mBAAmB,MAAc;IACtD,MAAM,cAAc,MAAM,iBAAiB,QAAQ,GAAG,CAAC,mBAAmB;IAC1E,IAAI;QACH,MAAM,mBAAmB,MAAM,IAAI,uJAAA,CAAA,UAAO,CAAC;YAAE,KAAK;QAAQ,GACxD,kBAAkB,CAAC;YAAE,KAAK;QAAQ,GAClC,WAAW,GACX,iBAAiB,CAAC,OAClB,IAAI,CAAC;QAEP,OAAO;IACR,EAAE,OAAO,KAAK;QACb,QAAQ,KAAK,CAAC,yBAAyB;IACxC;AACD;AAQO,eAAe,iBAAiB,GAAW;IACjD,gDAAgD;IAChD,MAAM,IAAI,OAAO,CAAC,QAAQ;IAE1B,6BAA6B;IAC7B,MAAM,IAAI,OAAO,CAAC,SAAS,MAAM,OAAO,CAAC,OAAO;IAEhD,6DAA6D;IAC7D,MAAM,IAAI,IAAI;IAEd,MAAM,YAAY;IAClB,MAAM,YAAY;IAElB,IAAI,CAAC,IAAI,UAAU,CAAC,cAAc,CAAC,IAAI,QAAQ,CAAC,YAAY;QAC3D,MAAM,IAAI,MAAM;IACjB;IAEA,6DAA6D;IAC7D,MAAM,cAAc,IAClB,SAAS,CAAC,UAAU,MAAM,EAAE,IAAI,MAAM,GAAG,UAAU,MAAM,EACzD,OAAO,CAAC,YAAY,KAAK,+CAA+C;IAE1E,kDAAkD;IAClD,MAAM,kBAAkB,OAAO,IAAI,CAAC,aAAa;IAEjD,IAAI;QACH,OAAO,MAAM,WAAW,MAAM,CAAC,MAAM,CAAC,SAAS,CAC9C,SACA,iBACA;YACC,MAAM;YACN,MAAM;QACP,GACA,MACA;YAAC;SAAO;IAEV,EAAE,OAAO,KAAK;QACb,QAAQ,IAAI,CACX;QAED,MAAM;IACP;AACD","debugId":null}},
    {"offset": {"line": 204, "column": 0}, "map": {"version":3,"sources":["file:///Users/jackmu/Documents/haligram/nextjs/src/db/schema.ts"],"sourcesContent":["import { randomUUID } from \"crypto\";\nimport { sqliteTable, text } from \"drizzle-orm/sqlite-core\";\nimport { InferSelectModel } from \"drizzle-orm\";\n\nexport const user = sqliteTable(\"users\", {\n\tid: text(\"id\").primaryKey().$defaultFn(() => randomUUID()),\n\tname: text(\"name\").notNull(),\n\temail: text(\"email\").notNull().unique(),\n});\nexport type User = InferSelectModel<typeof user>\n\nexport const redditToken = sqliteTable(\"RedditTokens\", {\n\tid: text(\"id\").primaryKey().$defaultFn(() => randomUUID()),\n\tuserId: text(\"userId\").references(() => user.id).notNull(),\n\taccessToken: text(\"accessToken\").notNull(),\n\trefreshToken: text(\"refreshToken\").notNull(),\n\tupdatedAt: text(\"updatedAt\").$defaultFn(() => (new Date()).toUTCString()),\n});\nexport type RedditToken = InferSelectModel<typeof redditToken>\n\nexport const redditSearch = sqliteTable(\"RedditSearch\", {\n\tid: text(\"id\").primaryKey().$defaultFn(() => randomUUID()),\n\tuserId: text(\"userId\").references(() => user.id).notNull(),\n\tsearches: text(\"searches\", { mode: \"json\" }).$type<{ terms: Array<string> }>(),\n});\nexport type RedditSearch = InferSelectModel<typeof redditSearch>\n"],"names":[],"mappings":";;;;;AAAA;AACA;AAAA;;;AAGO,MAAM,OAAO,CAAA,GAAA,2JAAA,CAAA,cAAW,AAAD,EAAE,SAAS;IACxC,IAAI,CAAA,GAAA,qKAAA,CAAA,OAAI,AAAD,EAAE,MAAM,UAAU,GAAG,UAAU,CAAC,IAAM,CAAA,GAAA,qGAAA,CAAA,aAAU,AAAD;IACtD,MAAM,CAAA,GAAA,qKAAA,CAAA,OAAI,AAAD,EAAE,QAAQ,OAAO;IAC1B,OAAO,CAAA,GAAA,qKAAA,CAAA,OAAI,AAAD,EAAE,SAAS,OAAO,GAAG,MAAM;AACtC;AAGO,MAAM,cAAc,CAAA,GAAA,2JAAA,CAAA,cAAW,AAAD,EAAE,gBAAgB;IACtD,IAAI,CAAA,GAAA,qKAAA,CAAA,OAAI,AAAD,EAAE,MAAM,UAAU,GAAG,UAAU,CAAC,IAAM,CAAA,GAAA,qGAAA,CAAA,aAAU,AAAD;IACtD,QAAQ,CAAA,GAAA,qKAAA,CAAA,OAAI,AAAD,EAAE,UAAU,UAAU,CAAC,IAAM,KAAK,EAAE,EAAE,OAAO;IACxD,aAAa,CAAA,GAAA,qKAAA,CAAA,OAAI,AAAD,EAAE,eAAe,OAAO;IACxC,cAAc,CAAA,GAAA,qKAAA,CAAA,OAAI,AAAD,EAAE,gBAAgB,OAAO;IAC1C,WAAW,CAAA,GAAA,qKAAA,CAAA,OAAI,AAAD,EAAE,aAAa,UAAU,CAAC,IAAM,AAAC,IAAI,OAAQ,WAAW;AACvE;AAGO,MAAM,eAAe,CAAA,GAAA,2JAAA,CAAA,cAAW,AAAD,EAAE,gBAAgB;IACvD,IAAI,CAAA,GAAA,qKAAA,CAAA,OAAI,AAAD,EAAE,MAAM,UAAU,GAAG,UAAU,CAAC,IAAM,CAAA,GAAA,qGAAA,CAAA,aAAU,AAAD;IACtD,QAAQ,CAAA,GAAA,qKAAA,CAAA,OAAI,AAAD,EAAE,UAAU,UAAU,CAAC,IAAM,KAAK,EAAE,EAAE,OAAO;IACxD,UAAU,CAAA,GAAA,qKAAA,CAAA,OAAI,AAAD,EAAE,YAAY;QAAE,MAAM;IAAO,GAAG,KAAK;AACnD","debugId":null}},
    {"offset": {"line": 239, "column": 0}, "map": {"version":3,"sources":["file:///Users/jackmu/Documents/haligram/nextjs/src/db/queries.ts"],"sourcesContent":["import 'dotenv/config';\nimport { drizzle } from 'drizzle-orm/libsql';\nimport { createClient } from '@libsql/client';\nimport { redditSearch, RedditSearch, RedditToken, redditToken, User, user } from './schema';\nimport { eq } from 'drizzle-orm';\n\nconst db = drizzle(\n\tcreateClient({\n\t\turl: process.env.TURSO_DATABASE_URL!,\n\t\tauthToken: process.env.TURSO_AUTH_TOKEN ?? \"\",\n\t})\n)\n\nexport const createUser = async (email: string, name: string): Promise<Array<User>> => {\n\ttry {\n\t\tconst createdUser = db.insert(user).values({\n\t\t\temail: email,\n\t\t\tname: name\n\t\t}).returning();\n\t\treturn createdUser;\n\t} catch (err) {\n\t\tconsole.error(\"unable to create user\", err);\n\t\tthrow err;\n\t}\n}\n\nexport const getUser = async (email: string, name: string): Promise<Array<User>> => {\n\ttry {\n\t\tlet selectedUser = await db.select().from(user).where(eq(user.email, email));\n\t\tif (selectedUser.length === 0) {\n\t\t\tselectedUser = await createUser(email, name);\n\t\t}\n\t\treturn selectedUser;\n\t} catch (err) {\n\t\tconsole.error(\"Failed to get user by email\", err);\n\t\tthrow err;\n\t}\n}\n\nexport const getRedditTokenByEmail = async (email: string): Promise<Array<RedditToken>> => {\n\ttry {\n\t\tconst selectedUser = await db.select().from(user).where(eq(user.email, email));\n\t\tif (selectedUser.length === 0) {\n\t\t\tconsole.error(\"no token for user\");\n\t\t\treturn [];\n\t\t}\n\t\tconst token = await db.select().from(redditToken)\n\t\t\t.where(eq(redditToken.userId, selectedUser[0].id));\n\t\treturn token;\n\t} catch (err) {\n\t\tconsole.error(\"Failed to get reddit token by email\", err);\n\t\tthrow err;\n\t}\n\n}\n\nexport const deleteRedditTokenByEmail = async (email: string) => {\n\ttry {\n\t\tconst selectedUser = await db.select().from(user).where(eq(user.email, email));\n\t\tif (selectedUser.length === 0) {\n\t\t\tconsole.error(\"no token for user\");\n\t\t\treturn;\n\t\t}\n\t\tawait db.delete(redditToken).where(eq(redditToken.userId, selectedUser[0].id));\n\t} catch (err) {\n\t\tconsole.error('unable to delete reddit token: ', err);\n\t\tthrow err;\n\t}\n\n}\n\nexport const upsertToken = async (email: string, accessToken: string, refreshToken: string): Promise<Array<RedditToken>> => {\n\ttry {\n\t\tconst selectedUser = await db.select().from(user).where(eq(user.email, email));\n\t\tif (selectedUser.length === 0) {\n\t\t\tconsole.error(\"no token for user\");\n\t\t\treturn [];\n\t\t}\n\t\tconst existingToken = await getRedditTokenByEmail(email);\n\t\tif (existingToken.length === 0) {\n\t\t\tconst token = await db.insert(redditToken).values({\n\t\t\t\tuserId: selectedUser[0].id,\n\t\t\t\taccessToken: accessToken,\n\t\t\t\trefreshToken: refreshToken,\n\t\t\t}).returning();\n\t\t\treturn token;\n\t\t} else {\n\t\t\tconst token = await db.update(redditToken)\n\t\t\t\t.set({\n\t\t\t\t\taccessToken: accessToken,\n\t\t\t\t\trefreshToken: refreshToken,\n\t\t\t\t\tupdatedAt: (new Date()).toUTCString(),\n\t\t\t\t})\n\t\t\t\t.where(eq(redditToken.userId, selectedUser[0].id))\n\t\t\t\t.returning();\n\t\t\treturn token;\n\t\t}\n\n\t} catch (err) {\n\t\tconsole.error(\"Failed to upsert reddit token\", err);\n\t\tthrow err;\n\t}\n}\n\nexport const getRedditSearchByEmail = async (email: string): Promise<Array<RedditSearch>> => {\n\ttry {\n\t\tconst selectedUser = await db.select().from(user).where(eq(user.email, email));\n\t\tif (selectedUser.length === 0) {\n\t\t\tconsole.error(\"no token for user\");\n\t\t\treturn [];\n\t\t}\n\t\tconst search = await db.select().from(redditSearch)\n\t\t\t.where(eq(redditSearch.userId, selectedUser[0].id));\n\t\treturn search;\n\n\t} catch (err) {\n\t\tconsole.error(\"failed to get reddit searches\", err);\n\t\tthrow err;\n\t}\n}\n\n\nexport const upsertRedditSearch = async (email: string, searchTerm: string): Promise<Array<RedditSearch>> => {\n\ttry {\n\t\tconst selectedUser = await db.select().from(user).where(eq(user.email, email));\n\t\tif (selectedUser.length === 0) {\n\t\t\tconsole.error(\"no token for user\");\n\t\t\treturn [];\n\t\t}\n\t\tconst pastSearch = await getRedditSearchByEmail(email);\n\t\tif (pastSearch.length === 0) {\n\t\t\tconst search = await db.insert(redditSearch).values({\n\t\t\t\tuserId: selectedUser[0].id,\n\t\t\t\tsearches: { terms: [searchTerm] },\n\t\t\t}).returning();\n\t\t\treturn search;\n\t\t} else {\n\t\t\tconst searches: Array<string> = pastSearch[0].searches!.terms;\n\t\t\tsearches.unshift(searchTerm);\n\t\t\tif (searches.length > 10) {\n\t\t\t\tsearches.pop();\n\t\t\t}\n\n\t\t\tconst newSearch = await db.update(redditSearch)\n\t\t\t\t.set({\n\t\t\t\t\tsearches: { terms: searches }\n\t\t\t\t})\n\t\t\t\t.where(eq(redditSearch.userId, selectedUser[0].id))\n\t\t\t\t.returning();\n\t\t\treturn newSearch;\n\t\t}\n\t} catch (err) {\n\t\tconsole.error(\"Failed to upsert reddit search\", err);\n\t\tthrow err;\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 403, "column": 0}, "map": {"version":3,"sources":["file:///Users/jackmu/Documents/haligram/nextjs/src/app/%28reddit%29/api/reddit/check-auth/route.ts"],"sourcesContent":["import { auth } from \"@/auth\";\nimport { getRedditTokenByEmail, getUser } from \"@/db/queries\";\n\nexport async function GET() {\n\tconst session = await auth();\n\tif (!session || !session.user) {\n\t\treturn Response.json({\n\t\t\tstatus: 400,\n\t\t\tmessage: \"user has not authenticated\"\n\t\t});\n\t} else if (!session.user.name || !session.user.email) {\n\t\treturn Response.json({\n\t\t\tstatus: 500,\n\t\t\tmessage: \"problem getting session\"\n\t\t});\n\n\t}\n\tconst user = await getUser(session.user.email, session.user.name);\n\tconst hasToken = (await getRedditTokenByEmail(user[0].email)).length === 0 ? false : true;\n\treturn Response.json({ hasAuth: hasToken })\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;;;;;AAEO,eAAe;IACrB,MAAM,UAAU,MAAM,CAAA,GAAA,6GAAA,CAAA,OAAI,AAAD;IACzB,IAAI,CAAC,WAAW,CAAC,QAAQ,IAAI,EAAE;QAC9B,OAAO,SAAS,IAAI,CAAC;YACpB,QAAQ;YACR,SAAS;QACV;IACD,OAAO,IAAI,CAAC,QAAQ,IAAI,CAAC,IAAI,IAAI,CAAC,QAAQ,IAAI,CAAC,KAAK,EAAE;QACrD,OAAO,SAAS,IAAI,CAAC;YACpB,QAAQ;YACR,SAAS;QACV;IAED;IACA,MAAM,OAAO,MAAM,CAAA,GAAA,sHAAA,CAAA,UAAO,AAAD,EAAE,QAAQ,IAAI,CAAC,KAAK,EAAE,QAAQ,IAAI,CAAC,IAAI;IAChE,MAAM,WAAW,CAAC,MAAM,CAAA,GAAA,sHAAA,CAAA,wBAAqB,AAAD,EAAE,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,EAAE,MAAM,KAAK,IAAI,QAAQ;IACrF,OAAO,SAAS,IAAI,CAAC;QAAE,SAAS;IAAS;AAC1C","debugId":null}}]
}