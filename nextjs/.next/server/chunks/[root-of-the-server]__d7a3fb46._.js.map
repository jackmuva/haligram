{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 94, "column": 0}, "map": {"version":3,"sources":["file:///Users/jackmu/Documents/haligram/src/db/schema.ts"],"sourcesContent":["import { randomUUID } from \"crypto\";\nimport { sqliteTable, text } from \"drizzle-orm/sqlite-core\";\nimport { InferSelectModel } from \"drizzle-orm\";\n\nexport const user = sqliteTable(\"users\", {\n\tid: text(\"id\").primaryKey().$defaultFn(() => randomUUID()),\n\tname: text(\"name\").notNull(),\n\temail: text(\"email\").notNull().unique(),\n});\nexport type User = InferSelectModel<typeof user>\n\nexport const redditToken = sqliteTable(\"RedditTokens\", {\n\tid: text(\"id\").primaryKey().$defaultFn(() => randomUUID()),\n\tuserId: text(\"userId\").references(() => user.id).notNull(),\n\taccessToken: text(\"accessToken\").notNull(),\n\trefreshToken: text(\"refreshToken\").notNull(),\n\tupdatedAt: text(\"updatedAt\").$defaultFn(() => (new Date()).toUTCString()),\n});\nexport type RedditToken = InferSelectModel<typeof redditToken>\n\nexport const redditSearch = sqliteTable(\"RedditSearch\", {\n\tid: text(\"id\").primaryKey().$defaultFn(() => randomUUID()),\n\tuserId: text(\"userId\").references(() => user.id).notNull(),\n\tsearches: text(\"searches\", { mode: \"json\" }).$type<{ terms: Array<string> }>(),\n});\nexport type RedditSearch = InferSelectModel<typeof redditSearch>\n"],"names":[],"mappings":";;;;;AAAA;AACA;AAAA;;;AAGO,MAAM,OAAO,CAAA,GAAA,2JAAA,CAAA,cAAW,AAAD,EAAE,SAAS;IACxC,IAAI,CAAA,GAAA,qKAAA,CAAA,OAAI,AAAD,EAAE,MAAM,UAAU,GAAG,UAAU,CAAC,IAAM,CAAA,GAAA,qGAAA,CAAA,aAAU,AAAD;IACtD,MAAM,CAAA,GAAA,qKAAA,CAAA,OAAI,AAAD,EAAE,QAAQ,OAAO;IAC1B,OAAO,CAAA,GAAA,qKAAA,CAAA,OAAI,AAAD,EAAE,SAAS,OAAO,GAAG,MAAM;AACtC;AAGO,MAAM,cAAc,CAAA,GAAA,2JAAA,CAAA,cAAW,AAAD,EAAE,gBAAgB;IACtD,IAAI,CAAA,GAAA,qKAAA,CAAA,OAAI,AAAD,EAAE,MAAM,UAAU,GAAG,UAAU,CAAC,IAAM,CAAA,GAAA,qGAAA,CAAA,aAAU,AAAD;IACtD,QAAQ,CAAA,GAAA,qKAAA,CAAA,OAAI,AAAD,EAAE,UAAU,UAAU,CAAC,IAAM,KAAK,EAAE,EAAE,OAAO;IACxD,aAAa,CAAA,GAAA,qKAAA,CAAA,OAAI,AAAD,EAAE,eAAe,OAAO;IACxC,cAAc,CAAA,GAAA,qKAAA,CAAA,OAAI,AAAD,EAAE,gBAAgB,OAAO;IAC1C,WAAW,CAAA,GAAA,qKAAA,CAAA,OAAI,AAAD,EAAE,aAAa,UAAU,CAAC,IAAM,AAAC,IAAI,OAAQ,WAAW;AACvE;AAGO,MAAM,eAAe,CAAA,GAAA,2JAAA,CAAA,cAAW,AAAD,EAAE,gBAAgB;IACvD,IAAI,CAAA,GAAA,qKAAA,CAAA,OAAI,AAAD,EAAE,MAAM,UAAU,GAAG,UAAU,CAAC,IAAM,CAAA,GAAA,qGAAA,CAAA,aAAU,AAAD;IACtD,QAAQ,CAAA,GAAA,qKAAA,CAAA,OAAI,AAAD,EAAE,UAAU,UAAU,CAAC,IAAM,KAAK,EAAE,EAAE,OAAO;IACxD,UAAU,CAAA,GAAA,qKAAA,CAAA,OAAI,AAAD,EAAE,YAAY;QAAE,MAAM;IAAO,GAAG,KAAK;AACnD","debugId":null}},
    {"offset": {"line": 129, "column": 0}, "map": {"version":3,"sources":["file:///Users/jackmu/Documents/haligram/src/db/queries.ts"],"sourcesContent":["import 'dotenv/config';\nimport { drizzle } from 'drizzle-orm/libsql';\nimport { createClient } from '@libsql/client';\nimport { redditSearch, RedditSearch, RedditToken, redditToken, User, user } from './schema';\nimport { eq } from 'drizzle-orm';\n\nconst db = drizzle(\n\tcreateClient({\n\t\turl: process.env.TURSO_DATABASE_URL!,\n\t\tauthToken: process.env.TURSO_AUTH_TOKEN ?? \"\",\n\t})\n)\n\nexport const createUser = async (email: string, name: string): Promise<Array<User>> => {\n\ttry {\n\t\tconst createdUser = db.insert(user).values({\n\t\t\temail: email,\n\t\t\tname: name\n\t\t}).returning();\n\t\treturn createdUser;\n\t} catch (err) {\n\t\tconsole.error(\"unable to create user\", err);\n\t\tthrow err;\n\t}\n}\n\nexport const getUser = async (email: string, name: string): Promise<Array<User>> => {\n\ttry {\n\t\tlet selectedUser = await db.select().from(user).where(eq(user.email, email));\n\t\tif (selectedUser.length === 0) {\n\t\t\tselectedUser = await createUser(email, name);\n\t\t}\n\t\treturn selectedUser;\n\t} catch (err) {\n\t\tconsole.error(\"Failed to get user by email\", err);\n\t\tthrow err;\n\t}\n}\n\nexport const getRedditTokenByEmail = async (email: string): Promise<Array<RedditToken>> => {\n\ttry {\n\t\tconst selectedUser = await db.select().from(user).where(eq(user.email, email));\n\t\tif (selectedUser.length === 0) {\n\t\t\tconsole.error(\"no token for user\");\n\t\t\treturn [];\n\t\t}\n\t\tconst token = await db.select().from(redditToken)\n\t\t\t.where(eq(redditToken.userId, selectedUser[0].id));\n\t\treturn token;\n\t} catch (err) {\n\t\tconsole.error(\"Failed to get reddit token by email\", err);\n\t\tthrow err;\n\t}\n\n}\n\nexport const deleteRedditTokenByEmail = async (email: string) => {\n\ttry {\n\t\tconst selectedUser = await db.select().from(user).where(eq(user.email, email));\n\t\tif (selectedUser.length === 0) {\n\t\t\tconsole.error(\"no token for user\");\n\t\t\treturn;\n\t\t}\n\t\tawait db.delete(redditToken).where(eq(redditToken.userId, selectedUser[0].id));\n\t} catch (err) {\n\t\tconsole.error('unable to delete reddit token: ', err);\n\t\tthrow err;\n\t}\n\n}\n\nexport const upsertToken = async (email: string, accessToken: string, refreshToken: string): Promise<Array<RedditToken>> => {\n\ttry {\n\t\tconst selectedUser = await db.select().from(user).where(eq(user.email, email));\n\t\tif (selectedUser.length === 0) {\n\t\t\tconsole.error(\"no token for user\");\n\t\t\treturn [];\n\t\t}\n\t\tconst existingToken = await getRedditTokenByEmail(email);\n\t\tif (existingToken.length === 0) {\n\t\t\tconst token = await db.insert(redditToken).values({\n\t\t\t\tuserId: selectedUser[0].id,\n\t\t\t\taccessToken: accessToken,\n\t\t\t\trefreshToken: refreshToken,\n\t\t\t}).returning();\n\t\t\treturn token;\n\t\t} else {\n\t\t\tconst token = await db.update(redditToken)\n\t\t\t\t.set({\n\t\t\t\t\taccessToken: accessToken,\n\t\t\t\t\trefreshToken: refreshToken,\n\t\t\t\t\tupdatedAt: (new Date()).toUTCString(),\n\t\t\t\t})\n\t\t\t\t.where(eq(redditToken.userId, selectedUser[0].id))\n\t\t\t\t.returning();\n\t\t\treturn token;\n\t\t}\n\n\t} catch (err) {\n\t\tconsole.error(\"Failed to upsert reddit token\", err);\n\t\tthrow err;\n\t}\n}\n\nexport const getRedditSearchByEmail = async (email: string): Promise<Array<RedditSearch>> => {\n\ttry {\n\t\tconst selectedUser = await db.select().from(user).where(eq(user.email, email));\n\t\tif (selectedUser.length === 0) {\n\t\t\tconsole.error(\"no token for user\");\n\t\t\treturn [];\n\t\t}\n\t\tconst search = await db.select().from(redditSearch)\n\t\t\t.where(eq(redditSearch.userId, selectedUser[0].id));\n\t\treturn search;\n\n\t} catch (err) {\n\t\tconsole.error(\"failed to get reddit searches\", err);\n\t\tthrow err;\n\t}\n}\n\n\nexport const upsertRedditSearch = async (email: string, searchTerm: string): Promise<Array<RedditSearch>> => {\n\ttry {\n\t\tconst selectedUser = await db.select().from(user).where(eq(user.email, email));\n\t\tif (selectedUser.length === 0) {\n\t\t\tconsole.error(\"no token for user\");\n\t\t\treturn [];\n\t\t}\n\t\tconst pastSearch = await getRedditSearchByEmail(email);\n\t\tif (pastSearch.length === 0) {\n\t\t\tconst search = await db.insert(redditSearch).values({\n\t\t\t\tuserId: selectedUser[0].id,\n\t\t\t\tsearches: { terms: [searchTerm] },\n\t\t\t}).returning();\n\t\t\treturn search;\n\t\t} else {\n\t\t\tconst searches: Array<string> = pastSearch[0].searches!.terms;\n\t\t\tsearches.unshift(searchTerm);\n\t\t\tif (searches.length > 10) {\n\t\t\t\tsearches.pop();\n\t\t\t}\n\n\t\t\tconst newSearch = await db.update(redditSearch)\n\t\t\t\t.set({\n\t\t\t\t\tsearches: { terms: searches }\n\t\t\t\t})\n\t\t\t\t.where(eq(redditSearch.userId, selectedUser[0].id))\n\t\t\t\t.returning();\n\t\t\treturn newSearch;\n\t\t}\n\t} catch (err) {\n\t\tconsole.error(\"Failed to upsert reddit search\", err);\n\t\tthrow err;\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 301, "column": 0}, "map": {"version":3,"sources":["file:///Users/jackmu/Documents/haligram/src/app/%28auth%29/api/oauth/reddit/callback/route.ts"],"sourcesContent":["import { upsertToken } from \"@/db/queries\";\nimport { NextRequest } from \"next/server\";\nimport { NextResponse } from \"next/server\";\n\nexport async function GET(req: NextRequest) {\n\tconst searchParams = new URL(req.url).searchParams;\n\tconst email = searchParams.get(\"state\");\n\tconst code = searchParams.get(\"code\");\n\n\tconst data = new URLSearchParams({\n\t\tgrant_type: 'authorization_code',\n\t\tcode: code!,\n\t\tredirect_uri: `${process.env.APPLICATION_URL}/api/oauth/reddit/callback`\n\t});\n\n\ttry {\n\t\tconst response = await fetch(\"https://www.reddit.com/api/v1/access_token\", {\n\t\t\tmethod: \"POST\",\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/x-www-form-urlencoded',\n\t\t\t\t'Authorization': 'Basic ' + Buffer.from(`${process.env.REDDIT_CLIENT_ID}:${process.env.REDDIT_CLIENT_SECRET}`).toString(\"base64\"),\n\t\t\t},\n\t\t\tbody: data.toString(),\n\t\t});\n\n\t\tconst body = await response.json();\n\t\tawait upsertToken(email!, body.access_token, body.refresh_token);\n\t\treturn NextResponse.redirect(process.env.APPLICATION_URL!, { status: 307 });\n\t} catch (err) {\n\t\tconsole.error(\"unable to retrieve reddit token:\", err);\n\t\treturn NextResponse.redirect(process.env.APPLICATION_URL!, { status: 307 });\n\t};\n}\n"],"names":[],"mappings":";;;AAAA;AAEA;;;;;;;AAEO,eAAe,IAAI,GAAgB;IACzC,MAAM,eAAe,IAAI,IAAI,IAAI,GAAG,EAAE,YAAY;IAClD,MAAM,QAAQ,aAAa,GAAG,CAAC;IAC/B,MAAM,OAAO,aAAa,GAAG,CAAC;IAE9B,MAAM,OAAO,IAAI,gBAAgB;QAChC,YAAY;QACZ,MAAM;QACN,cAAc,GAAG,QAAQ,GAAG,CAAC,eAAe,CAAC,0BAA0B,CAAC;IACzE;IAEA,IAAI;QACH,MAAM,WAAW,MAAM,MAAM,8CAA8C;YAC1E,QAAQ;YACR,SAAS;gBACR,gBAAgB;gBAChB,iBAAiB,WAAW,OAAO,IAAI,CAAC,GAAG,QAAQ,GAAG,CAAC,gBAAgB,CAAC,CAAC,EAAE,QAAQ,GAAG,CAAC,oBAAoB,EAAE,EAAE,QAAQ,CAAC;YACzH;YACA,MAAM,KAAK,QAAQ;QACpB;QAEA,MAAM,OAAO,MAAM,SAAS,IAAI;QAChC,MAAM,CAAA,GAAA,sHAAA,CAAA,cAAW,AAAD,EAAE,OAAQ,KAAK,YAAY,EAAE,KAAK,aAAa;QAC/D,OAAO,gIAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,QAAQ,GAAG,CAAC,eAAe,EAAG;YAAE,QAAQ;QAAI;IAC1E,EAAE,OAAO,KAAK;QACb,QAAQ,KAAK,CAAC,oCAAoC;QAClD,OAAO,gIAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,QAAQ,GAAG,CAAC,eAAe,EAAG;YAAE,QAAQ;QAAI;IAC1E;;AACD","debugId":null}}]
}